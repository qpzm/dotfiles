# vim: set expandtab:

global !p
def collect_ale_lint_codes(linter_name):
    if not vim.eval('get(g:, "ale_enabled", 0)'):
        # works only if ALE is installed and enabled
        return ''

    # find all relevant linting (e.g. pylint) codes for the current line
    # TODO: ALE does not expose an API for getting all loclist items for the current line
    all_lints = vim.eval('get(ale#util#FindItemAtCursor(bufnr(""))[0], "loclist")')
    current_line = vim.current.window.cursor[0]

    codes = set()
    for lint in all_lints:
        lnum = int(lint['lnum'])
        if lnum == current_line:
            if lint['linter_name'] == linter_name:
                codes.add(lint['code'])
        elif lnum > current_line:
            # loclist is in an ascending order of line number
            break

    return ",".join(codes)

endglobal

# Add 'pylint: disable=...' marker
snippet pylint
# pylint: disable=${1:`!p snip.rv = collect_ale_lint_codes("pylint")`}
endsnippet

# Add a typecheck if-raise statement.
# TODO: auto-retrieve type annotation from the current python context.
snippet typecheck
if not isinstance(${1}, ${2:object}):
	raise TypeError("\`$1\` must be a $2, but given {}".format($2, type($1)))
endsnippet
snippet TypeError(
TypeError("\`$1\` must be a ${2:object}, but given {}".format($2, type($1)))
endsnippet

snippet rangecheck
if not ${3:0} <= ${1} < ${2:n}:
	raise IndexError("Index out of range [{}, {}), but given {}".format($3, $2, $1))
endsnippet
